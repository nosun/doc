#php面向对象学习#

###面向过程思想###
- 以事件为中心的思想
- 分析解决问题所需要的步骤
- 用函数把这些步骤一步一步实现
- 使用的时候依次调用
##面向对象思想##
###万物皆对象###
1. 对象是对人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看做对象，它不仅能表示具体的事物，还能表示抽象的规则，计划或事件
- 对象的状态和行为
1. 对象具有状态，一个对象用数据值来描述它的状态。
2. 对象还有操作，用于改变对象的状态，操作就是对象的行为，对象实现了数据和操作的结合，使数据和操作封装于对象的统一体中。
###什么是面向对象###
- 面向对象是以功能来划分问题，而不是步骤
- 注重的是对象，对象的使用
- 只有面向对象的程序，采真正符合人类的思维逻辑;
- 世界是由各种各样具有自己的运动规律和内部状态的对象组成的，不同对象之间的相互作用和通讯构成了完整的现实世界。因此，人们应当按照现实世界这个本来面貌来理解世界，直接通过对象及其相互关系来反映世界。这样建立起来的系统才能符合世界的本来面目。
- 它强调系统的结构应该直接与现实世界的结构相对应，应该围绕现实世界的对象来构造系统，而不是围绕功能来构造系统。
###面向对象的重要优势###
- 可读性
- 可重用性
- 稳定性
- 维护性
- 可测试性
###案例分析###
以下五子棋的游戏为例
###类和对象的关系###
- 类：对象的描述，模；类型，类别。按照属性对事物进行分类;
- 对象的两个主要特性
	- 对象的行为：可以对对象施加哪些操作：如电视机的开、关、转换频道；
	- 对象的状态：当施加那些方法时，对象如何响应；如电视机的外形，尺寸，颜色；
###如何抽象一个类###
- 类的声明
	class BoyFriend {
		public $name;
		public $age='24';
		public $sex='男';
		public $height='175cm';	

		function cooking(){
			return "做饭的功能<br />";
			}
		function cleaner(){
			return "做家务的功能<br />";
			}
	}
- 成员属性
- 成员方法
###内存划分###
- 栈内存
- 堆内存
- 初始化静态段
- 代码段

理解如何实例化对象的过程，非php真实的存储情况。
- 栈较小，栈里面适合存一些定长的东西，对象的句柄放在这里。
- 堆很大，占90%，变长的东西，实例化的对象就放在这里，对象的首地址作为指针，指针的值作为变量放在栈内存中。
- 代码段，结构的代码放在里面，类代码放在这里。

###特殊的的对象引用$this###
- 必须使用对象来访问对象的成员
- 特殊对象的引用$this就是在对象内部的成员方法中，代表本对象的一个引用，但只能在对象的成员方法中使用，不管是在对象内部使用$this访问自己对象内部成员.还是在对象外部通过对象的引用名称访问对象中的成员，都需要使用特殊的运算符"->"来完成访问。

###php 构造方法###
- 对象创建完成以后，第一个自动调用的方法;
- 方法名称比较特殊，需要和类名相同的方法名;
- 给对象中的成员赋值使用;
- __construct(); 魔术方法,和构造方法的功能完全一样,但名字是统一的;php独有。

###析构函数###
- 对象在消失之前，自动调用的一个方法，在内存中释放;
- __destruct(); 释放对象前调用，对象遗言;
- 析构函数没有参数;
- 平时用的不多，释放对象操作的资源时，需要使用，比如文件，数据库;

##封装性##
###基本概念###
- 封装性是面向对象编程中的三大特性之一，封装就是把对象中的成员属性和成员方法你发加上访问修饰符，使其尽可能隐藏对象的内部细节，已达到对成员的访问控制。
- 封装实际上是对象的权限控制，一些功能，属性对内使用，一些属性，功能对外开放。
- 强内聚，弱耦合。
- 构造方法，不用封装，析构方法，不用封装。
- 属性封装，方法封装：属性一般都设置为private;
- 可以对属性在设置前进行判断和处理。

###魔术方法###
- __get()： 直接读取私有属性时，自动调用;
- __set():  设置私有属性
- __isset() 在使用isset()判断一个私有属性是否存在时，自动调用__isset()魔术方法，变量为属性名称;
- __unset() 销毁对象中成员属性方法

##类的继承##
- 单继承，一个类仅允许有一个父类。
- 多个类，提取公共部分，做成父类，实现代码的复用。
- 继承---扩展 extends 子类可以将父类的所有内容都继承过来。
- protected 继承中，将需要给子类使用的属性设置为protected.
- 类调用方法使用 “::”，classname::function_name();用parent::function_name()；访问父类中被覆盖的方法。
- important：只要是子类的构造方法，去覆盖父类中的构造方法，一定要在子类的最上面调用一下父类被覆盖的方法。
- 权限问题：子类的权限一定要大于等于父类的权限，如果父类是public的，子类不能是protected或者private的。

##面向对象常见关键字##
- instanceof 用于检测当前实例是否属于某一个类，返回真假。
- final		 
	- final修饰类，类不能有子类，不让别人去扩展，是最终的。
	- final可以修饰方法，这个方法不能在子类中重写，覆盖。
- static
	- 多个对象公用的一个属性，可以用static关键字修饰并赋值。
	- 修饰属性 修饰成员属性，存在内存的初始化静态段，可以被同一个类的对象共用。在类首次被加载的时候就已经将静态的成员加载到了内存。
		- 可以用类调用：classname::$var;静态的成员一定要用类来访问。
		- 使用classname::$var='value'; 可以进行赋值。
	- 修饰方法 静态的方法和静态属性类似，直接可以用类访问，和面向对象的过程类似。
		- 在静态方法中不能访问非静态成员。
		- 只要是能使用静态的环境下，声明方法最好使用静态方法。（效率）
	- 静态成员一旦被加载，只有等到脚本结束时才被释放；
- self 可以在类的方法中，代表自己类的{$this};
- const 修饰成员属性为常量，只能修饰成员属性。
	- 常量建议使用大写，不能使用$符号
	- 常量一定要在声明时就赋予初值。
	- 常量的访问方式和static的访问方式相同，只能读，不可修改。
	- 在类外部使用类名::常量名 调取
	- 在类内部使用self::常量名 调取

##单态设计模式##
- 众多设计模式中的一种，也称为单例，单件设计模式。——最合适php使用这个设计模式。效率高。
- 如果想让一个类，只能有一个对象，就要先让这个类不能创建对象，将构造方法private。在类的内部使用一个方法来创建对象，将方法设置为静态方法,申明静态属性，$obj =null;
	class Person{
		static $obj =null;
		private function __construct(){

		}
		static function getobj(){
			if(isnull(self::$obj)){
				self::$obj =new self;
			}
			return self::$obj;
		}
	}

##魔术方法##
- __construct()
- __destruct()
- __set()
- __get()
- __isset()
- __unset()
- __tostring() 直接 echo 对象时，调用tostring 方法中的输出内容。tostring方法不能使用参数，并且必须要返回字符串。
- __clone()克隆对象，当使用clone 时调用__clone()方法，在这个方法中$this代表的是副本，可以给所有的副本的成员初始化。
- __call() 处理错误调用：在调用一个对象中不存在的方法时，自动调用的方法
	- 有两个参数，第一个参数是调用的不存在的方法的方法名，第二个是调用不存在的方法的参数。
	- 可以写提示，但这个不是主要的功能。将方法的功能相似，但方法名不同的就可以采用者这种方式来完成。
- __sleep() 在串行化时自动调用的方法，可以设置需要串行化的对象的属性。
	- 在这个方法中，返回一个数组，在数组中声明那个属性名，哪个属性就会被串行化，没有在其中的就不会被串行化输出。如果不加本方法，则默认将所有的属性输出。
- wakeup() 在反串行化时自动调用的方法，对串行化返回的对象进行初始化，和__construct(),clone()很相似。
- __set_state()用的不多，了解下。
	- eval() 检查并执行php代码。在字符串中存在php执行代码，将字符串放入eval，eval会检查代码并执行代码。$str="echo 'hello world!';";
	- var_export() 打印输出合法的，可用的数组变量。
	- 在使用var_export()方法时导出一个类的信息是自动调用的方法。
	- 必须要有一个参数，必须是静态的。
- __callstatic() 同__call()，针对静态方法不存在时输出错误信息。必须是公有的，静态的。
- __autoload() 自动加载类。简化include。
	- 在需要加载类的时候（必须用到类名），就会自动调用这个方法。
	- 当new实例化一个不存在的类时，自动调用此函数"__autoload()",并将类名作为参数传入此函数，我们可以使用这个功能实现类的自动加载。
	- 在组织定义类的文件名时，需要按照一定的规则，最好是以类名为中心，加上统一的前缀或者后缀的形式。

	function __autoload($classname){
		//test.class.php
		include strtolower($classname)."class.php";
	}

	$t=test();
	$t->one();


###特点###
- 自动调用，不同的魔术方法有自己的调用时机。
- 都是以__开始的
- 魔术方法是系统配置好的，方法名是固定的。

###对象串行化###
- 串行化（序列化）：将对象转成字符串
- 反串行化：将字符串转回为对象
- serialize() 将对象serialize之后就可以保存到文本或者进行网络传输了。
- $str=file_get_content('objstr.txt');unserialize($str)；对象就可以使用了。

##数组串行化json####
- json_encode 将数组转化为JavaScript obj。
- json_decode 将json格式转化为php数组格式，或者php对象，第二个参数为true，则反串行化为数组。

##抽象方法和抽象类##
###什么是抽象方法###
- 一个方法如果没有方法体(一个方法不使用{}，直接使用;结束的方法)，则这个方法就是抽象方法;
- 必须使用abstract 关键字修饰;

###什么是抽象类###
- 一个类中有一个方法是抽象的方法，则这个类就是抽象类;
- 如果申明一个抽象类，则这个类必须要使用abstract关键字来修饰。
- 抽象类是一种特殊的类，特殊在哪里？(在抽象类中可以有抽象方法)；
- 抽象类的其他方面和正常类是一样的。
- 抽象类不能实例化对象（不能new）。
- 如果看见抽象类，就必须写这个类的子类。
- 子类必须全部实现抽象方法，才能创建对象，如果只是实现部分，那么子类也仍然是抽象类

###抽象类和抽象方法有什么用?###
- 抽象方法的作用就是规定了，子类必须有这个方法;
- 只写出结构，而没有实现，实现交给具体的子类去实现;
- 抽象类的作用，就是规定了子类必须要实现所规定的方法，是类的抽象。

###面向对象接口技术###
- 抽象类是一种抽象的类，接口是一种特殊的抽象类，接口也是一种特殊的类.
- 接口中的方法，必须全是抽象方法;
- 接口中的成员属性，必须是常量;
- 接口的所有权限必须是公共的
- 声明接口不使用class, 而是使用interface关键字
- 接口方法里面，所有的方法都无需使用关键字abstract 关键字，实际上是抽象方法。

###面向对象接口应用的一些细节###
- 接口可以继承接口，extends
- 可以使用一个类来实现接口的全部方法，也可以使用抽象类来实现接口的部分方法。
- 类和接口之间使用实现关键字 implements,相当于extends。
- extends 继承 扩展，在php中，一个类只能有一个父类，而implements可以实现多个。
- 一个类可以在继承一个类的同时，可以使用implements实现一个或多个接口,要先继承，再实现接口。
- 实现多个接口只需要使用","分开多个接口即可。

###面向对象的多态###
- 程序扩展准备：形成规范性的东西，父类最好是接口或者抽象类。
- 例子
	interface USB {
		const WIDTH =12;
		const HEIGHT=3;
		function load();
		function run();
		function stop();
	}

	class Cumputer {
		function useUSB(USB $usb){
			$usb->load();
			$usb->run();
			$usb->stop();
		}
	}

	class Worker{
		function use(){
			$c= new Cumputer();
			$m= new Mouse();
			$c->useUSB($m);
		}
	}

	class Mouse implements USB{
		function load(){
			echo "加载鼠标成功！<br>";
		}

		function run(){
			echo "运行鼠标成功!<br>";

		}

		function stop(){
			echo "鼠标工作停止！<br>";
		}
	}

##php魔术常量##
- __CLASS__ 类名
- __METHOD__ 方法名

##面向对象系统函数##
- class_alias 类别名
- get_class_methods 获取类的所有方法。
- get_class_vars 获取类的成员属性。
- get_class 返回对象类名
- get_declared_class 返回已经定义的类
- get_declared_interfaces 返回一个数组，包含所有定义的接口。
- get_praent_class 取回父类名字
- interface_exists 接口是否存在
- method_exists    方法是否存在
- property_exists  属性是否存在